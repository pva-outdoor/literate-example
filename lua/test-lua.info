This is test-lua.info, produced by makeinfo version 7.1 from
test-lua.texi.


File: test-lua.info,  Node: Top,  Next: Приложения,  Up: (dir)

Демонстрация Literate Programming
*********************************

В тексте используется терминология, принятая в lua.  Например,
хеш-таблицы называются просто таблицами.

* Menu:

* Приложения::

-- The Detailed Node Listing --

Приложения

* Вывод структур на печать::
* Отладка внешних ссылок::

Вывод структур на печать

* Настройки форматирования::
* Поиск совпадений::
* Вывод на экран::
* Особенности реализации::



File: test-lua.info,  Node: Приложения,  Prev: Top,  Up: Top

1 Приложения
************

* Menu:

* Вывод структур на печать::
* Отладка внешних ссылок::


File: test-lua.info,  Node: Вывод структур на печать,  Next: Отладка внешних ссылок,  Up: Приложения

1.1 Вывод структур на печать
============================

В этом модуле предоставляется возможность выводить на экран
структурированные данные в отформатированном виде, понятном для
человека.  Модуль экспортирует одну единственную функцию ‘pprint’.  Эта
функция принимает на вход данные, которые нужно напечатать и
необязательную таблицу настроек:

     pprint(data, {...})

   Например, так можно вывести на экран все глобальные переменные:

     pprint(_G, {name="global variables"})

   И на выходе получим такое дерево:

     global variables:
      ├ _G: same as global variables
      ├ _VERSION: Lua 5.4
      ├ arg:
      │  ├ 0: lua
      │  ├ 1: -l
      │  ├ 2: pprint
      │  ├ 3: -l
      │  └ 4: profind
      ├ assert: function: 0x55eb7506b4f0
      ├ collectgarbage: function: 0x55eb7506c960
      ├ coroutine:
      │  ├ close: function: 0x55eb7506f5c0
      │  ├ create: function: 0x55eb7506d770
      │  ├ isyieldable: function: 0x55eb7506ea70
      │  ├ resume: function: 0x55eb7506d570
      │  ├ running: function: 0x55eb7506d880
      │  ├ status: function: 0x55eb7506eb00
      │  ├ wrap: function: 0x55eb7506e9b0
      │  └ yield: function: 0x55eb7506d8f0
      ├ debug:
      │  ├ debug: function: 0x55eb75072a50
      │  ├ gethook: function: 0x55eb750714b0
      │  ├ getinfo: function: 0x55eb75070520
      │  ├ getlocal: function: 0x55eb75070b90
      ...

   Таблицу настроек можно не передавать совсем, или передавать частично.
Тогда все не указанные настройки примут свои значения по умолчанию.  При
этом если передать ключи, которые не являются настройками, то последние
будут проигнорированы.

* Menu:

* Настройки форматирования::
* Поиск совпадений::
* Вывод на экран::
* Особенности реализации::


File: test-lua.info,  Node: Настройки форматирования,  Next: Поиск совпадений,  Up: Вывод структур на печать

1.1.1 Настройки форматирования
------------------------------

В качестве настроек форматирования можно указывать следующие:

ключ         описание                               по умолчанию
-------------------------------------------------------------------
name         название корневого элемента            <value>
search       критерий поиска                        показать всё
out          куда выводить данные (поток)           io.output()
maxlines     максимальное количество строк печати   24
maxdepth     максимальная глубина структуры         8
showlineno   показывать номера строк                нет
showtype     показывать типы данных lua             нет
bullets      см.  *note Отрисовка узлов::           линии
indent       см.  *note Отступы слева::             пробелы

  1. Ограничения размера вывода

     Обход дерева составных данных ограничен в длину (параметр
     ‘maxlines’) и глубину (параметр ‘maxdepth’).  Изменяя эти
     параметры, можно добиться различных эффектов.  Например, можно
     вывести всех функций работы со строками (модуль ‘string’),
     установив глубину обхода 1:

          pprint(string, {name="string", maxdepth=1})

  2. Отрисовка узлов

     Отрисовка линий, соединяющие узлы происходит подстановкой одной из
     четырёх строк ‘{midind, midbul, lastind, lastbul}’ в зависимости от
     структуры элементов.  Если указываете эту настройку, вы должны
     указать все 4 элемента сразу.

     midind
          отступ для элемента, после которого есть ещё один элемент
     midbul
          ответвление для элемента, после которого есть ещё один элемент
     lastind
          отступ для последнего элемента
     lastbul
          ответвление для последнего элемента

     Для сохранения хорошей читаемости при печати данных, эти строки
     должны иметь одинаковую длину при отображении.  Они могут иметь
     разную длину если, например, вы захотите добавить раскраску с
     использованием управляющих последовательностей ANSI, но при
     отображении они должны занимать одинаковое количество знакомест в
     ширину.

     Например, так можно визуально разрядить линии, показывающие
     структуру дерева:

          pprint(_G,
                {bullets = {"  │  ", "  ├─ ", "     ", "  └─ "}})

  3. Отступы слева

     Отрисовка отступов происходит подстановкой одной из двух строк
     ‘{leftind, leftbul}’.  Если указываете эту настройку, вы должны
     указать все 2 элемента сразу.

     leftind
          отступ без ответвлений
     leftbul
          отступ с ответвления для корневого элемента

     Для сохранения хорошей читаемости при печати данных, эти строки
     также должны иметь одинаковую длину при отображении (см *note
     Отрисовка узлов::).  Например, так можно сделать визуальное
     разделение дерева и номеров строк:

          pprint(_G, {indent={" ║ ", " ╖ "})


File: test-lua.info,  Node: Поиск совпадений,  Next: Вывод на экран,  Prev: Настройки форматирования,  Up: Вывод структур на печать

1.1.2 Поиск совпадений
----------------------

При выводе данных можно наложить фильтр, который скроет не интересующие
узлы и значения.  При этом будут показаны те узлы, названия или значения
которых представляют интерес, и узлы, содержащие интересующие узлы
внутри себя.  Если фильтр не указывается, то отображаются все узлы
структуры, иначе при выводе данные просеиваются через указанный фильтр и
название корневого элемента дополняется пометкой, что отображение
происходит с фильтрацией.

   Возможны следующие варианты для указания интересующих узлов:

   • совпадение строки с регулярным выражением ‘string.find’, например:

          pprint(data, {search = "work.-sec"})

   • задание функции, которая явно показывает, интересует ли указанный
     ключ или значение, например:

          pprint(data,
                     {search = function(x) return x[foo] == "bar" end})

   • Поиск какого-то определённого объекта (но не строки и не функции).
     В случае, если требуется найти определённую строку или функцию,
     нужно использовать первые два варианта отсеивания.  Например.
     можно найти таблицу:

          pprint(data, {search = some_table})

   Для циклических (рекурсивных) структур применение критерия поиска
происходит только один раз (используется подход ‘memoization’).

   В процессе отсеивания данных, сложные и простые данные обрабатываются
по-разному.  Для простых данных, их строковое представление (в случае
поиска по регулярному выражению) или их значение (в остальных случаях)
сравнивается с критерием поиска.  Если составные данные имеют
преобразование в строку (метаметод ‘__tostring’), то результат этого
преобразования также сравнивается с критерием поиска.

   В остальных случаях отображаются те компоненты составных данных, для
которых либо ключ, либо значение (рекурсивно) попадают под критерий
фильтра.


File: test-lua.info,  Node: Вывод на экран,  Next: Особенности реализации,  Prev: Поиск совпадений,  Up: Вывод структур на печать

1.1.3 Вывод на экран
--------------------

Количество строк, которые можно вывести на экран, ограничены настройкой
‘showlineno’.  Это сделано для того, чтобы не переполнять экран без
надобности.  Если вам действительно необходимо вывести всё на экран,
укажите какое-нибудь большое число.  Следует оставаться в разумных
пределах, ведь вряд ли вы хотите вывести на экран миллион строк.
Пример:

     pprint(data, {maxlines=10^5})

   Можно отобразить номера строк при печати, используя настройку
‘showlineno’.  Номера строк будут выведены слева (смещая всю картинку
вправо), например:

     pprint(data, {showlineno = true})

   При выводе на печать также предусмотрена защита от циклических
(рекурсивных) данных.  Под рекурсивными или циклическими данными
понимаются данные, которые содержат внутри ссылки на себя.  Каждая такая
ссылка отображается только один раз.  В случае, если она уже отображена,
повторно она отображаться не будет.  В этом случае будет отображаться
текст-заменитель в виде простого элемента.  Такое ограничение действует
только на составные данные (так как только такие данные могут содержать
циклы).

   В случае, если составные данные имеют преобразование в строку, они
будут отображаться как строка, а не как составные данные.  При этом при
повторном выводе таких данных (внутри одного сеанса печати) повторное
преобразование в строку выполнено не будет.  Это следует иметь в виду
при учёте сторонних эффектов преобразований в строку.  Например, если
нужно будет вывести элемент, значение которого меняется при каждой
попытке его прочитать, при повторении его внутри структуры, будет
выведено одно и то же значение.

   При печати простых данных возможны два варианта: вывод с типом данных
и без.  При выводе с типом данных, перед значением ключа составного
элемента будет в скобках отображаться его тип данных.

   Фильтр, отсеивающий отображаемое содержимое, применяется только к
ключам и значениям составных структур.  Поэтому простые данные,
указанные непосредственно в ‘pprint’ выведены будут всегда.  Например
следующий вызов напечатает ‘hello’ несмотря на то, что это слово не
подходит под фильтр отсеивания:

     pprint("hello", {search = "aaa"})

   Прошедшая отсеивание составная структура отображается в сортированном
по возрастанию значений ключей виде.  Ключи сортируются в зависимости от
их типа данных (используются операторы сравнения lua), поэтому и
числовые, и строковые ключи будут отсортированы правильно.


File: test-lua.info,  Node: Особенности реализации,  Prev: Вывод на экран,  Up: Вывод структур на печать

1.1.4 Особенности реализации
----------------------------

В случае возникновения ошибок при подготовке и выводе данных, вообще,
возможны два варианта.  В одном случае ошибки подавляются, точнее не
распространяются дальше функции печати.  Это вполне естественно, если
функция печати не является частью обязательной логики программы.  Но в
этом случае искать место в программе, где не удалось сделать вывод на
экран приходится самостоятельно.  При этом из полезной информации на
экран выводится только констатация факта ошибки.

   В случае, когда ошибка распространяется наружу из функции печати,
программа, вызывающая печать прерывается.  Если при этом позволить
ошибке полностью остановить выполнение программы и вывести на экран
стек, то можно отследить, в каком месте не удалось вывести на печать, и,
возможно, почему.

   В текущей реализации в случае возникновения ошибок при подготовке и
выводе данных, печать будет прерываться, но ошибка дальше
распространяться не будет.

   Следует отметить особенность такую реализации: модуль запоминает
функции (работы со строками, таблицами и т.д.), на которые он опирается.
После загрузки модуля переопределения этих функций на него не влияют.

   Для отладки использования внешних ссылок (а также правильности
использования локальных переменных), можно предварительно подключить
модуль ‘defvar’.  Это можно сделать, например, так:

     lua -l defvar -l pprint -i ваш-скрипт.lua


File: test-lua.info,  Node: Отладка внешних ссылок,  Prev: Вывод структур на печать,  Up: Приложения

1.2 Отладка внешних ссылок
==========================

В lua глобальные переменные объявляются очень легко.  Также доступ ко
всем функциям и библиотекам осуществляется как раз через глобальные
переменные.  Таким образом, добавив у себя в скрипте глобальную
переменную ‘print’ (просто забыв сделать её локальной), вы закрываете
себе доступ к функции ‘print’.  Чтобы отслеживать такие вещи, можно
использовать данный модуль.  После подключения модуля становится
невозможным создать глобальную переменную так:

     new_global_var = "значение"

   Если переменная ещё не была создана, то попытка сохранения в эту
переменную будет пресекаться вызовом ошибки:

     attempt to write to undeclared variable XXX

   А попытка чтения этой переменной будет выведена на экран:

     attempt to read undeclared variable XXX

   Для создания глобальной переменной теперь нужно будет сделать вызов
функции:

     defvar("new_global_var", "значение")

   В этом случае будет создана переменная с указанным значением (которое
не должно быть ‘nil’).  В lua значение ‘nil’ используется для удаления
элемента таблицы, поэтому присваивание такого значения приведёт к
автоматическому удалению глобальной переменной.

   Можно создать переменную без начального значения, и тогда она примет
значение ‘true’:

     defvar("new_global_var")



Tag Table:
Node: Top77
Node: Приложения826
Node: Вывод структур на печать1044
Node: Настройки форматирования3632
Ref: Ограничения размера вывода4919
Ref: Отрисовка узлов5524
Ref: Отступы слева7290
Node: Поиск совпадений8247
Node: Вывод на экран11595
Node: Особенности реализации16118
Node: Отладка внешних ссылок18819

End Tag Table


Local Variables:
coding: utf-8
End:
