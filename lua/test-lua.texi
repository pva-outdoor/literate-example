\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename test-lua.info
@settitle Демонстрация Literate Programming
@documentencoding UTF-8
@documentlanguage ru
@c %**end of header

@finalout
@titlepage
@title Демонстрация Literate Programming
@author Андрей Петров
@end titlepage

@contents

@ifnottex
@node Top
@top Демонстрация Literate Programming

В тексте используется терминология, принятая в lua. Например,
хеш-таблицы называются просто таблицами.
@end ifnottex

@menu
* Приложения::

@detailmenu
--- The Detailed Node Listing ---

Приложения

* Вывод структур на печать::
* Отладка внешних ссылок::

Вывод структур на печать

* Настройки форматирования::
* Поиск совпадений::
* Вывод на экран::
* Особенности реализации::

@end detailmenu
@end menu

@node Приложения
@chapter Приложения

@menu
* Вывод структур на печать::
* Отладка внешних ссылок::
@end menu

@node Вывод структур на печать
@section Вывод структур на печать

В этом модуле предоставляется возможность выводить на экран
структурированные данные в отформатированном виде, понятном для
человека. Модуль экспортирует одну единственную функцию @code{pprint}.  Эта
функция принимает на вход данные, которые нужно напечатать и
необязательную таблицу настроек:

@example
pprint(data, @{...@})
@end example

Например, так можно вывести на экран все глобальные переменные:

@example
pprint(_G, @{name="global variables"@})
@end example

И на выходе получим такое дерево:

@example
global variables:
 ├ _G: same as global variables
 ├ _VERSION: Lua 5.4
 ├ arg:
 │  ├ 0: lua
 │  ├ 1: -l
 │  ├ 2: pprint
 │  ├ 3: -l
 │  └ 4: profind
 ├ assert: function: 0x55eb7506b4f0
 ├ collectgarbage: function: 0x55eb7506c960
 ├ coroutine:
 │  ├ close: function: 0x55eb7506f5c0
 │  ├ create: function: 0x55eb7506d770
 │  ├ isyieldable: function: 0x55eb7506ea70
 │  ├ resume: function: 0x55eb7506d570
 │  ├ running: function: 0x55eb7506d880
 │  ├ status: function: 0x55eb7506eb00
 │  ├ wrap: function: 0x55eb7506e9b0
 │  └ yield: function: 0x55eb7506d8f0
 ├ debug:
 │  ├ debug: function: 0x55eb75072a50
 │  ├ gethook: function: 0x55eb750714b0
 │  ├ getinfo: function: 0x55eb75070520
 │  ├ getlocal: function: 0x55eb75070b90
 ...
@end example

Таблицу настроек можно не передавать совсем, или передавать
частично. Тогда все не указанные настройки примут свои значения по
умолчанию. При этом если передать ключи, которые не являются
настройками, то последние будут проигнорированы.

@menu
* Настройки форматирования::
* Поиск совпадений::
* Вывод на экран::
* Особенности реализации::
@end menu

@node Настройки форматирования
@subsection Настройки форматирования

В качестве настроек форматирования можно указывать следующие:

@multitable {aaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaa}
@headitem ключ
@tab описание
@tab по умолчанию
@item name
@tab название корневого элемента
@tab <value>
@item search
@tab критерий поиска
@tab показать всё
@item out
@tab куда выводить данные (поток)
@tab io.output()
@item maxlines
@tab максимальное количество строк печати
@tab 24
@item maxdepth
@tab максимальная глубина структуры
@tab 8
@item showlineno
@tab показывать номера строк
@tab нет
@item showtype
@tab показывать типы данных lua
@tab нет
@item bullets
@tab см. @ref{Отрисовка узлов}
@tab линии
@item indent
@tab см. @ref{Отступы слева}
@tab пробелы
@end multitable

@enumerate
@item
@anchor{Ограничения размера вывода}Ограничения размера вывода


Обход дерева составных данных ограничен в длину (параметр @code{maxlines})
и глубину (параметр @code{maxdepth}). Изменяя эти параметры, можно добиться
различных эффектов. Например, можно вывести всех функций работы со
строками (модуль @code{string}), установив глубину обхода 1:

@example
pprint(string, @{name="string", maxdepth=1@})
@end example

@item
@anchor{Отрисовка узлов}Отрисовка узлов


Отрисовка линий, соединяющие узлы происходит подстановкой одной из
четырёх строк @code{@{midind, midbul, lastind, lastbul@}} в зависимости от
структуры элементов. Если указываете эту настройку, вы должны указать
все 4 элемента сразу.

@table @asis
@item midind
отступ для элемента, после которого есть ещё один элемент
@item midbul
ответвление для элемента, после которого есть ещё один элемент
@item lastind
отступ для последнего элемента
@item lastbul
ответвление для последнего элемента
@end table

Для сохранения хорошей читаемости при печати данных, эти строки должны
иметь одинаковую длину при отображении. Они могут иметь разную длину
если, например, вы захотите добавить раскраску с использованием
управляющих последовательностей ANSI, но при отображении они должны
занимать одинаковое количество знакомест в ширину.

Например, так можно визуально разрядить линии, показывающие структуру
дерева:

@example
pprint(_G,
      @{bullets = @{"  │  ", "  ├─ ", "     ", "  └─ "@}@})
@end example

@item
@anchor{Отступы слева}Отступы слева


Отрисовка отступов происходит подстановкой одной из двух
строк @code{@{leftind, leftbul@}}. Если указываете эту настройку, вы должны
указать все 2 элемента сразу.

@table @asis
@item leftind
отступ без ответвлений
@item leftbul
отступ с ответвления для корневого элемента
@end table

Для сохранения хорошей читаемости при печати данных, эти строки также должны
иметь одинаковую длину при отображении (см @ref{Отрисовка узлов}).
Например, так можно сделать визуальное разделение дерева и номеров строк:

@example
pprint(_G, @{indent=@{" ║ ", " ╖ "@})
@end example
@end enumerate

@node Поиск совпадений
@subsection Поиск совпадений

При выводе данных можно наложить фильтр, который скроет не
интересующие узлы и значения. При этом будут показаны те узлы,
названия или значения которых представляют интерес, и узлы, содержащие
интересующие узлы внутри себя. Если фильтр не указывается, то
отображаются все узлы структуры, иначе при выводе данные просеиваются
через указанный фильтр и название корневого элемента дополняется
пометкой, что отображение происходит с фильтрацией.

Возможны следующие варианты для указания интересующих узлов:

@itemize
@item
совпадение строки с регулярным выражением @code{string.find}, например:

@example
pprint(data, @{search = "work.-sec"@})
@end example

@item
задание функции, которая явно показывает, интересует ли указанный
ключ или значение, например:

@example
pprint(data,
           @{search = function(x) return x[foo] == "bar" end@})
@end example

@item
Поиск какого-то определённого объекта (но не строки и не функции). В
случае, если требуется найти определённую строку или функцию, нужно
использовать первые два варианта отсеивания. Например. можно найти
таблицу:

@example
pprint(data, @{search = some_table@})
@end example
@end itemize

Для циклических (рекурсивных) структур применение критерия поиска
происходит только один раз (используется подход @code{memoization}).

В процессе отсеивания данных, сложные и простые данные обрабатываются по-разному.
Для простых данных, их строковое представление (в случае поиска по
регулярному выражению) или их значение (в остальных случаях)
сравнивается с критерием поиска.
Если составные данные имеют преобразование в строку (метаметод
@code{__tostring}), то результат этого преобразования также сравнивается с
критерием поиска.

В остальных случаях отображаются те компоненты составных данных, для
которых либо ключ, либо значение (рекурсивно) попадают под критерий фильтра.

@node Вывод на экран
@subsection Вывод на экран

Количество строк, которые можно вывести на экран, ограничены
настройкой @code{showlineno}. Это сделано для того, чтобы не переполнять
экран без надобности. Если вам действительно необходимо вывести всё на
экран, укажите какое-нибудь большое число. Следует оставаться в
разумных пределах, ведь вряд ли вы хотите вывести на экран миллион
строк. Пример:

@example
pprint(data, @{maxlines=10^5@})
@end example

Можно отобразить номера строк при печати, используя настройку
@code{showlineno}. Номера строк будут выведены слева (смещая всю картинку
вправо), например:

@example
pprint(data, @{showlineno = true@})
@end example

При выводе на печать также предусмотрена защита от циклических
(рекурсивных) данных. Под рекурсивными или циклическими данными
понимаются данные, которые содержат внутри ссылки на себя. Каждая
такая ссылка отображается только один раз. В случае, если она уже
отображена, повторно она отображаться не будет. В этом случае будет
отображаться текст-заменитель в виде простого элемента. Такое
ограничение действует только на составные данные (так как только такие
данные могут содержать циклы).

В случае, если составные данные имеют преобразование в строку, они
будут отображаться как строка, а не как составные данные. При этом
при повторном выводе таких данных (внутри одного сеанса печати)
повторное преобразование в строку выполнено не будет. Это следует
иметь в виду при учёте сторонних эффектов преобразований в строку.
Например, если нужно будет вывести элемент, значение которого меняется
при каждой попытке его прочитать, при повторении его внутри структуры,
будет выведено одно и то же значение.

При печати простых данных возможны два варианта: вывод с типом данных
и без. При выводе с типом данных, перед значением ключа составного
элемента будет в скобках отображаться его тип данных.

Фильтр, отсеивающий отображаемое содержимое, применяется только к
ключам и значениям составных структур. Поэтому простые данные,
указанные непосредственно в @code{pprint} выведены будут всегда. Например
следующий вызов напечатает @code{hello} несмотря на то, что это слово не
подходит под фильтр отсеивания:

@example
pprint("hello", @{search = "aaa"@})
@end example

Прошедшая отсеивание составная структура отображается в сортированном
по возрастанию значений ключей виде. Ключи сортируются в зависимости
от их типа данных (используются операторы сравнения lua), поэтому
и числовые, и строковые ключи будут отсортированы правильно.

@node Особенности реализации
@subsection Особенности реализации

В случае возникновения ошибок при подготовке и выводе данных, вообще,
возможны два варианта. В одном случае ошибки подавляются, точнее не
распространяются дальше функции печати. Это вполне естественно, если
функция печати не является частью обязательной логики программы.  Но в
этом случае искать место в программе, где не удалось сделать вывод на
экран приходится самостоятельно. При этом из полезной информации на
экран выводится только констатация факта ошибки.

В случае, когда ошибка распространяется наружу из функции печати,
программа, вызывающая печать прерывается. Если при этом позволить
ошибке полностью остановить выполнение программы и вывести на экран
стек, то можно отследить, в каком месте не удалось вывести на печать,
и, возможно, почему.

В текущей реализации в случае возникновения ошибок при подготовке и
выводе данных, печать будет прерываться, но ошибка дальше
распространяться не будет.

Следует отметить особенность такую реализации: модуль запоминает
функции (работы со строками, таблицами и т.д.), на которые он
опирается. После загрузки модуля переопределения этих функций на него
не влияют.

Для отладки использования внешних ссылок (а также правильности
использования локальных переменных), можно предварительно подключить
модуль @code{defvar}. Это можно сделать, например, так:

@example
lua -l defvar -l pprint -i ваш-скрипт.lua
@end example

@node Отладка внешних ссылок
@section Отладка внешних ссылок

В lua глобальные переменные объявляются очень легко. Также доступ ко
всем функциям и библиотекам осуществляется как раз через глобальные
переменные. Таким образом, добавив у себя в скрипте глобальную
переменную @code{print} (просто забыв сделать её локальной), вы закрываете
себе доступ к функции @code{print}. Чтобы отслеживать такие вещи, можно
использовать данный модуль. После подключения модуля становится
невозможным создать глобальную переменную так:

@example
new_global_var = "значение"
@end example

Если переменная ещё не была создана, то попытка сохранения в эту
переменную будет пресекаться вызовом ошибки:

@example
attempt to write to undeclared variable XXX
@end example


А попытка чтения этой переменной будет выведена на экран:

@example
attempt to read undeclared variable XXX
@end example


Для создания глобальной переменной теперь нужно будет сделать вызов
функции:

@example
defvar("new_global_var", "значение")
@end example

В этом случае будет создана переменная с указанным значением (которое
не должно быть @code{nil}). В lua значение @code{nil} используется для удаления
элемента таблицы, поэтому присваивание такого значения приведёт к
автоматическому удалению глобальной переменной.

Можно создать переменную без начального значения, и тогда она примет
значение @code{true}:

@example
defvar("new_global_var")
@end example

@bye